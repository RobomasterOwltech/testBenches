Only in /Users/jperezch/Downloads/Development-Board-C-Examples/20.standard_robot: .DS_Store
Only in .: .vscode
Only in ./MDK-ARM: DebugConfig
Only in ./MDK-ARM: RTE
Only in ./MDK-ARM: all_remote.uvguix.sofia
Only in ./MDK-ARM: all_remote.uvoptx
Only in ./MDK-ARM: all_remote.uvprojx
Only in /Users/jperezch/Downloads/Development-Board-C-Examples/20.standard_robot/MDK-ARM: standard_robot.uvprojx
Only in ./MDK-ARM: standard_tpye_c
Only in ./MDK-ARM: startup_stm32f407xx.lst
diff -bur ./Src/freertos.c /Users/jperezch/Downloads/Development-Board-C-Examples/20.standard_robot/Src/freertos.c
--- ./Src/freertos.c	2024-04-23 13:44:24
+++ /Users/jperezch/Downloads/Development-Board-C-Examples/20.standard_robot/Src/freertos.c	2024-04-08 11:10:52
@@ -144,13 +144,13 @@
 
   /* Create the thread(s) */
   /* definition and creation of test */
-  //osThreadDef(test, test_task, osPriorityNormal, 0, 128);
-  //testHandle = osThreadCreate(osThread(test), NULL);
+  osThreadDef(test, test_task, osPriorityNormal, 0, 128);
+  testHandle = osThreadCreate(osThread(test), NULL);
 
   /* USER CODE BEGIN RTOS_THREADS */
   /* add threads, ... */
-    //osThreadDef(cali, calibrate_task, osPriorityNormal, 0, 512);
-    //calibrate_tast_handle = osThreadCreate(osThread(cali), NULL);
+    osThreadDef(cali, calibrate_task, osPriorityNormal, 0, 512);
+    calibrate_tast_handle = osThreadCreate(osThread(cali), NULL);
 
     osThreadDef(ChassisTask, chassis_task, osPriorityAboveNormal, 0, 512);
     chassisTaskHandle = osThreadCreate(osThread(ChassisTask), NULL);
diff -bur ./Src/usart.c /Users/jperezch/Downloads/Development-Board-C-Examples/20.standard_robot/Src/usart.c
--- ./Src/usart.c	2024-04-23 13:44:24
+++ /Users/jperezch/Downloads/Development-Board-C-Examples/20.standard_robot/Src/usart.c	2024-04-08 11:10:52
@@ -160,7 +160,7 @@
     */
     GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_10;
     GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
-    GPIO_InitStruct.Pull = GPIO_PULLDOWN;
+    GPIO_InitStruct.Pull = GPIO_PULLUP;
     GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
     GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
     HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
diff -bur ./application/chassis_behaviour.c /Users/jperezch/Downloads/Development-Board-C-Examples/20.standard_robot/application/chassis_behaviour.c
--- ./application/chassis_behaviour.c	2024-04-23 13:44:24
+++ /Users/jperezch/Downloads/Development-Board-C-Examples/20.standard_robot/application/chassis_behaviour.c	2024-04-08 11:10:52
@@ -2,7 +2,7 @@
   ****************************(C) COPYRIGHT 2019 DJI****************************
   * @file       chassis_behaviour.c/h
   * @brief      according to remote control, change the chassis behaviour.
-  *             根据遥控器的值，决定底盘行为。
   * @note       
   * @history
   *  Version    Date            Author          Modification
@@ -46,31 +46,31 @@
         }
 
         
-    如果要添加一个新的行为模式
-    1.首先，在chassis_behaviour.h文件中， 添加一个新行为名字在 chassis_behaviour_e
     erum
     {  
         ...
         ...
-        CHASSIS_XXX_XXX, // 新添加的
     }chassis_behaviour_e,
 
-    2. 实现一个新的函数 chassis_xxx_xxx_control(fp32 *vx, fp32 *vy, fp32 *wz, chassis_move_t * chassis )
-        "vx,vy,wz" 参数是底盘运动控制输入量
-        第一个参数: 'vx' 通常控制纵向移动,正值 前进， 负值 后退
-        第二个参数: 'vy' 通常控制横向移动,正值 左移, 负值 右移
-        第三个参数: 'wz' 可能是角度控制或者旋转速度控制
-        在这个新的函数, 你能给 "vx","vy",and "wz" 赋值想要的速度参数
-    3.  在"chassis_behaviour_mode_set"这个函数中，添加新的逻辑判断，给chassis_behaviour_mode赋值成CHASSIS_XXX_XXX
-        在函数最后，添加"else if(chassis_behaviour_mode == CHASSIS_XXX_XXX)" ,然后选择一种底盘控制模式
-        4种:
-        CHASSIS_VECTOR_FOLLOW_GIMBAL_YAW : 'vx' and 'vy'是速度控制， 'wz'是角度控制 云台和底盘的相对角度
-        你可以命名成"xxx_angle_set"而不是'wz'
-        CHASSIS_VECTOR_FOLLOW_CHASSIS_YAW : 'vx' and 'vy'是速度控制， 'wz'是角度控制 底盘的陀螺仪计算出的绝对角度
-        你可以命名成"xxx_angle_set"
-        CHASSIS_VECTOR_NO_FOLLOW_YAW : 'vx' and 'vy'是速度控制， 'wz'是旋转速度控制
-        CHASSIS_VECTOR_RAW : 使用'vx' 'vy' and 'wz'直接线性计算出车轮的电流值，电流值将直接发送到can 总线上
-    4.  在"chassis_behaviour_control_set" 函数的最后，添加
         else if(chassis_behaviour_mode == CHASSIS_XXX_XXX)
         {
             chassis_xxx_xxx_control(vx_set, vy_set, angle_set, chassis_move_rc_to_vector);
@@ -98,13 +98,13 @@
   * @retval         none
   */
 /**
-  * @brief          底盘无力的行为状态机下，底盘模式是raw，故而设定值会直接发送到can总线上故而将设定值都设置为0
   * @author         RM
-  * @param[in]      vx_set前进的速度 设定值将直接发送到can总线上
-  * @param[in]      vy_set左右的速度 设定值将直接发送到can总线上
-  * @param[in]      wz_set旋转的速度 设定值将直接发送到can总线上
-  * @param[in]      chassis_move_rc_to_vector底盘数据
-  * @retval         返回空
   */
 static void chassis_zero_force_control(fp32 *vx_can_set, fp32 *vy_can_set, fp32 *wz_can_set, chassis_move_t *chassis_move_rc_to_vector);
 
@@ -119,13 +119,13 @@
   * @retval         none
   */
 /**
-  * @brief          底盘不移动的行为状态机下，底盘模式是不跟随角度，
   * @author         RM
-  * @param[in]      vx_set前进的速度,正值 前进速度， 负值 后退速度
-  * @param[in]      vy_set左右的速度,正值 左移速度， 负值 右移速度
-  * @param[in]      wz_set旋转的速度，旋转速度是控制底盘的底盘角速度
-  * @param[in]      chassis_move_rc_to_vector底盘数据
-  * @retval         返回空
   */
 static void chassis_no_move_control(fp32 *vx_set, fp32 *vy_set, fp32 *wz_set, chassis_move_t *chassis_move_rc_to_vector);
 
@@ -139,13 +139,13 @@
   * @retval         none
   */
 /**
-  * @brief          底盘跟随云台的行为状态机下，底盘模式是跟随云台角度，底盘旋转速度会根据角度差计算底盘旋转的角速度
   * @author         RM
-  * @param[in]      vx_set前进的速度,正值 前进速度， 负值 后退速度
-  * @param[in]      vy_set左右的速度,正值 左移速度， 负值 右移速度
-  * @param[in]      angle_set底盘与云台控制到的相对角度
-  * @param[in]      chassis_move_rc_to_vector底盘数据
-  * @retval         返回空
   */
 static void chassis_infantry_follow_gimbal_yaw_control(fp32 *vx_set, fp32 *vy_set, fp32 *angle_set, chassis_move_t *chassis_move_rc_to_vector);
 
@@ -159,13 +159,13 @@
   * @retval         none
   */
 /**
-  * @brief          底盘跟随底盘yaw的行为状态机下，底盘模式是跟随底盘角度，底盘旋转速度会根据角度差计算底盘旋转的角速度
   * @author         RM
-  * @param[in]      vx_set前进的速度,正值 前进速度， 负值 后退速度
-  * @param[in]      vy_set左右的速度,正值 左移速度， 负值 右移速度
-  * @param[in]      angle_set底盘设置的yaw，范围 -PI到PI
-  * @param[in]      chassis_move_rc_to_vector底盘数据
-  * @retval         返回空
   */
 static void chassis_engineer_follow_chassis_yaw_control(fp32 *vx_set, fp32 *vy_set, fp32 *angle_set, chassis_move_t *chassis_move_rc_to_vector);
 
@@ -179,13 +179,13 @@
   * @retval         none
   */
 /**
-  * @brief          底盘不跟随角度的行为状态机下，底盘模式是不跟随角度，底盘旋转速度由参数直接设定
   * @author         RM
-  * @param[in]      vx_set前进的速度,正值 前进速度， 负值 后退速度
-  * @param[in]      vy_set左右的速度,正值 左移速度， 负值 右移速度
-  * @param[in]      wz_set底盘设置的旋转速度,正值 逆时针旋转，负值 顺时针旋转
-  * @param[in]      chassis_move_rc_to_vector底盘数据
-  * @retval         返回空
   */
 static void chassis_no_follow_yaw_control(fp32 *vx_set, fp32 *vy_set, fp32 *wz_set, chassis_move_t *chassis_move_rc_to_vector);
 
@@ -201,11 +201,11 @@
   * @retval         none
   */
 /**
-  * @brief          底盘开环的行为状态机下，底盘模式是raw原生状态，故而设定值会直接发送到can总线上
-  * @param[in]      vx_set前进的速度,正值 前进速度， 负值 后退速度
-  * @param[in]      vy_set左右的速度，正值 左移速度， 负值 右移速度
-  * @param[in]      wz_set 旋转速度， 正值 逆时针旋转，负值 顺时针旋转
-  * @param[in]      chassis_move_rc_to_vector底盘数据
   * @retval         none
   */
 
@@ -217,7 +217,7 @@
 
 
 //highlight, the variable chassis behaviour mode 
-//留意，这个底盘行为模式变量
 chassis_behaviour_e chassis_behaviour_mode = CHASSIS_ZERO_FORCE;
 
 
@@ -227,8 +227,8 @@
   * @retval         none
   */
 /**
-  * @brief          通过逻辑判断，赋值"chassis_behaviour_mode"成哪种模式
-  * @param[in]      chassis_move_mode: 底盘数据
   * @retval         none
   */
 void chassis_behaviour_mode_set(chassis_move_t *chassis_move_mode)
@@ -240,7 +240,7 @@
 
 
     //remote control  set chassis behaviour mode
-    //遥控器设置模式
     if (switch_is_mid(chassis_move_mode->chassis_RC->rc.s[CHASSIS_MODE_CHANNEL]))
     {
         //can change to CHASSIS_ZERO_FORCE,CHASSIS_NO_MOVE,CHASSIS_INFANTRY_FOLLOW_GIMBAL_YAW,
@@ -257,7 +257,7 @@
     }
 
     //when gimbal in some mode, such as init mode, chassis must's move
-    //当云台在某些模式下，像初始化， 底盘不动
     if (gimbal_cmd_to_chassis_stop())
     {
         chassis_behaviour_mode = CHASSIS_NO_MOVE;
@@ -265,11 +265,11 @@
 
 
     //add your own logic to enter the new mode
-    //添加自己的逻辑判断进入新模式
 
 
     //accord to beheviour mode, choose chassis control mode
-    //根据行为模式选择一个底盘控制模式
     if (chassis_behaviour_mode == CHASSIS_ZERO_FORCE)
     {
         chassis_move_mode->chassis_mode = CHASSIS_VECTOR_RAW; 
@@ -307,11 +307,11 @@
   * @retval         none
   */
 /**
-  * @brief          设置控制量.根据不同底盘控制模式，三个参数会控制不同运动.在这个函数里面，会调用不同的控制函数.
-  * @param[out]     vx_set, 通常控制纵向移动.
-  * @param[out]     vy_set, 通常控制横向移动.
-  * @param[out]     wz_set, 通常控制旋转运动.
-  * @param[in]      chassis_move_rc_to_vector,  包括底盘所有信息.
   * @retval         none
   */
 
@@ -360,13 +360,13 @@
   * @retval         none
   */
 /**
-  * @brief          底盘无力的行为状态机下，底盘模式是raw，故而设定值会直接发送到can总线上故而将设定值都设置为0
   * @author         RM
-  * @param[in]      vx_set前进的速度 设定值将直接发送到can总线上
-  * @param[in]      vy_set左右的速度 设定值将直接发送到can总线上
-  * @param[in]      wz_set旋转的速度 设定值将直接发送到can总线上
-  * @param[in]      chassis_move_rc_to_vector底盘数据
-  * @retval         返回空
   */
 
 static void chassis_zero_force_control(fp32 *vx_can_set, fp32 *vy_can_set, fp32 *wz_can_set, chassis_move_t *chassis_move_rc_to_vector)
@@ -390,13 +390,13 @@
   * @retval         none
   */
 /**
-  * @brief          底盘不移动的行为状态机下，底盘模式是不跟随角度，
   * @author         RM
-  * @param[in]      vx_set前进的速度,正值 前进速度， 负值 后退速度
-  * @param[in]      vy_set左右的速度,正值 左移速度， 负值 右移速度
-  * @param[in]      wz_set旋转的速度，旋转速度是控制底盘的底盘角速度
-  * @param[in]      chassis_move_rc_to_vector底盘数据
-  * @retval         返回空
   */
 
 static void chassis_no_move_control(fp32 *vx_set, fp32 *vy_set, fp32 *wz_set, chassis_move_t *chassis_move_rc_to_vector)
@@ -420,13 +420,13 @@
   * @retval         none
   */
 /**
-  * @brief          底盘跟随云台的行为状态机下，底盘模式是跟随云台角度，底盘旋转速度会根据角度差计算底盘旋转的角速度
   * @author         RM
-  * @param[in]      vx_set前进的速度,正值 前进速度， 负值 后退速度
-  * @param[in]      vy_set左右的速度,正值 左移速度， 负值 右移速度
-  * @param[in]      angle_set底盘与云台控制到的相对角度
-  * @param[in]      chassis_move_rc_to_vector底盘数据
-  * @retval         返回空
   */
 
 static void chassis_infantry_follow_gimbal_yaw_control(fp32 *vx_set, fp32 *vy_set, fp32 *angle_set, chassis_move_t *chassis_move_rc_to_vector)
@@ -437,25 +437,25 @@
     }
 
     //channel value and keyboard value change to speed set-point, in general
-    //遥控器的通道值以及键盘按键 得出 一般情况下的速度设定值
     chassis_rc_to_control_vector(vx_set, vy_set, chassis_move_rc_to_vector);
 
     //swing angle is generated by sin function, swing_time is the input time of sin
-    //摇摆角度是利用sin函数生成，swing_time 是sin函数的输入值
     static fp32 swing_time = 0.0f;
     
     static fp32 swing_angle = 0.0f;
     //max_angle is the max angle that chassis will ratate
-    //max_angle 是sin函数的幅值
     static fp32 max_angle = SWING_NO_MOVE_ANGLE;
     //swing_time  plus the add_time in one control cycle
-    //swing_time 在一个控制周期内，加上 add_time
     static fp32 const add_time = PI * 0.5f * configTICK_RATE_HZ / CHASSIS_CONTROL_TIME_MS;
     
     static uint8_t swing_flag = 0;
 
     //judge if swing
-    //判断是否要摇摆
     if (chassis_move_rc_to_vector->chassis_RC->key.v & SWING_KEY)
     {
         if (swing_flag == 0)
@@ -470,7 +470,7 @@
     }
 
     //judge if keyboard is controlling the chassis, if yes, reduce the max_angle
-    //判断键盘输入是不是在控制底盘运动，底盘在运动减小摇摆角度
     if (chassis_move_rc_to_vector->chassis_RC->key.v & CHASSIS_FRONT_KEY || chassis_move_rc_to_vector->chassis_RC->key.v & CHASSIS_BACK_KEY ||
         chassis_move_rc_to_vector->chassis_RC->key.v & CHASSIS_LEFT_KEY || chassis_move_rc_to_vector->chassis_RC->key.v & CHASSIS_RIGHT_KEY)
     {
@@ -491,7 +491,7 @@
         swing_angle = 0.0f;
     }
     //swing_time  range [0, 2*PI]
-    //sin函数不超过2pi
     if (swing_time > 2 * PI)
     {
         swing_time -= 2 * PI;
@@ -511,13 +511,13 @@
   * @retval         none
   */
 /**
-  * @brief          底盘跟随底盘yaw的行为状态机下，底盘模式是跟随底盘角度，底盘旋转速度会根据角度差计算底盘旋转的角速度
   * @author         RM
-  * @param[in]      vx_set前进的速度,正值 前进速度， 负值 后退速度
-  * @param[in]      vy_set左右的速度,正值 左移速度， 负值 右移速度
-  * @param[in]      angle_set底盘设置的yaw，范围 -PI到PI
-  * @param[in]      chassis_move_rc_to_vector底盘数据
-  * @retval         返回空
   */
 
 static void chassis_engineer_follow_chassis_yaw_control(fp32 *vx_set, fp32 *vy_set, fp32 *angle_set, chassis_move_t *chassis_move_rc_to_vector)
@@ -542,13 +542,13 @@
   * @retval         none
   */
 /**
-  * @brief          底盘不跟随角度的行为状态机下，底盘模式是不跟随角度，底盘旋转速度由参数直接设定
   * @author         RM
-  * @param[in]      vx_set前进的速度,正值 前进速度， 负值 后退速度
-  * @param[in]      vy_set左右的速度,正值 左移速度， 负值 右移速度
-  * @param[in]      wz_set底盘设置的旋转速度,正值 逆时针旋转，负值 顺时针旋转
-  * @param[in]      chassis_move_rc_to_vector底盘数据
-  * @retval         返回空
   */
 
 static void chassis_no_follow_yaw_control(fp32 *vx_set, fp32 *vy_set, fp32 *wz_set, chassis_move_t *chassis_move_rc_to_vector)
@@ -572,11 +572,11 @@
   * @retval         none
   */
 /**
-  * @brief          底盘开环的行为状态机下，底盘模式是raw原生状态，故而设定值会直接发送到can总线上
-  * @param[in]      vx_set前进的速度,正值 前进速度， 负值 后退速度
-  * @param[in]      vy_set左右的速度，正值 左移速度， 负值 右移速度
-  * @param[in]      wz_set 旋转速度， 正值 逆时针旋转，负值 顺时针旋转
-  * @param[in]      chassis_move_rc_to_vector底盘数据
   * @retval         none
   */
 
diff -bur ./application/chassis_task.h /Users/jperezch/Downloads/Development-Board-C-Examples/20.standard_robot/application/chassis_task.h
--- ./application/chassis_task.h	2024-04-23 13:44:24
+++ /Users/jperezch/Downloads/Development-Board-C-Examples/20.standard_robot/application/chassis_task.h	2024-04-08 11:10:52
@@ -2,11 +2,11 @@
   ****************************(C) COPYRIGHT 2019 DJI****************************
   * @file       chassis.c/h
   * @brief      chassis control task,
   * @note       
   * @history
   *  Version    Date            Author          Modification
   *  V1.1.0     Nov-11-2019     RM              1. add chassis power control
   *
   @verbatim
@@ -26,41 +26,41 @@
 #include "user_lib.h"
 
 //in the beginning of task ,wait a time
 #define CHASSIS_TASK_INIT_TIME 357
 
 //the channel num of controlling vertial speed 
-#define CHASSIS_X_CHANNEL 3
+#define CHASSIS_X_CHANNEL 1
 //the channel num of controlling horizontal speed
-#define CHASSIS_Y_CHANNEL 1
+#define CHASSIS_Y_CHANNEL 0
 
 //in some mode, can use remote control to control rotation speed
-#define CHASSIS_WZ_CHANNEL 0
+#define CHASSIS_WZ_CHANNEL 2
 
 //the channel of choosing chassis mode,
-#define CHASSIS_MODE_CHANNEL 6//rc.sc[1] //todo:sera???
+#define CHASSIS_MODE_CHANNEL 0
 //rocker value (max 660) change to vertial speed (m/s) 
 #define CHASSIS_VX_RC_SEN 0.006f
 //rocker value (max 660) change to horizontal speed (m/s)
 #define CHASSIS_VY_RC_SEN 0.005f
 //in following yaw angle mode, rocker value add to angle 
 #define CHASSIS_ANGLE_Z_RC_SEN 0.000002f
 //in not following yaw angle mode, rocker value change to rotation speed
 #define CHASSIS_WZ_RC_SEN 0.01f
 
 #define CHASSIS_ACCEL_X_NUM 0.1666666667f
 #define CHASSIS_ACCEL_Y_NUM 0.3333333333f
 
 //rocker value deadline
 #define CHASSIS_RC_DEADLINE 10
 
 #define MOTOR_SPEED_TO_CHASSIS_SPEED_VX 0.25f
@@ -71,53 +71,53 @@
 #define MOTOR_DISTANCE_TO_CENTER 0.2f
 
 //chassis task control time  2ms
 #define CHASSIS_CONTROL_TIME_MS 2
 //chassis task control time 0.002s
 #define CHASSIS_CONTROL_TIME 0.002f
 //chassis control frequence, no use now.
 #define CHASSIS_CONTROL_FREQUENCE 500.0f
 //chassis 3508 max motor control current
 #define MAX_MOTOR_CAN_CURRENT 16000.0f
 //press the key, chassis will swing
 #define SWING_KEY KEY_PRESSED_OFFSET_CTRL
 //chassi forward, back, left, right key
 #define CHASSIS_FRONT_KEY KEY_PRESSED_OFFSET_W
 #define CHASSIS_BACK_KEY KEY_PRESSED_OFFSET_S
 #define CHASSIS_LEFT_KEY KEY_PRESSED_OFFSET_A
 #define CHASSIS_RIGHT_KEY KEY_PRESSED_OFFSET_D
 
 //m3508 rmp change to chassis speed,
 #define M3508_MOTOR_RPM_TO_VECTOR 0.000415809748903494517209f
 #define CHASSIS_MOTOR_RPM_TO_VECTOR_SEN M3508_MOTOR_RPM_TO_VECTOR
 
 //single chassis motor max speed
 #define MAX_WHEEL_SPEED 4.0f
 //chassis forward or back max speed
 #define NORMAL_MAX_CHASSIS_SPEED_X 2.0f
 //chassis left or right max speed
 #define NORMAL_MAX_CHASSIS_SPEED_Y 1.5f
 
 #define CHASSIS_WZ_SET_SCALE 0.1f
 
 //when chassis is not set to move, swing max angle
 #define SWING_NO_MOVE_ANGLE 0.7f
 //when chassis is set to move, swing max angle
 #define SWING_MOVE_ANGLE 0.31415926535897932384626433832795f
 
 //chassis motor speed PID
 #define M3505_MOTOR_SPEED_PID_KP 15000.0f
 #define M3505_MOTOR_SPEED_PID_KI 10.0f
 #define M3505_MOTOR_SPEED_PID_KD 0.0f
@@ -125,7 +125,7 @@
 #define M3505_MOTOR_SPEED_PID_MAX_IOUT 2000.0f
 
 //chassis follow angle PID
 #define CHASSIS_FOLLOW_GIMBAL_PID_KP 40.0f
 #define CHASSIS_FOLLOW_GIMBAL_PID_KI 0.0f
 #define CHASSIS_FOLLOW_GIMBAL_PID_KD 0.0f
@@ -134,9 +134,9 @@
 
 typedef enum
 {
   CHASSIS_VECTOR_RAW,                 //control-current will be sent to CAN bus derectly.
 
 } chassis_mode_e;
@@ -152,36 +152,36 @@
 
 typedef struct
 {
 
 
   fp32 chassis_yaw_set;             
 
 
 } chassis_move_t;
 
@@ -191,8 +191,8 @@
   * @retval         none
   */
 /**
   * @retval         none
   */
 extern void chassis_task(void const *pvParameters);
@@ -206,11 +206,11 @@
   * @retval         none
   */
 /**
   *                 
   * @retval         none
   */
 extern void chassis_rc_to_control_vector(fp32 *vx_set, fp32 *vy_set, chassis_move_t *chassis_move_rc_to_vector);
diff -bur ./application/detect_task.c /Users/jperezch/Downloads/Development-Board-C-Examples/20.standard_robot/application/detect_task.c
--- ./application/detect_task.c	2024-04-23 13:44:24
+++ /Users/jperezch/Downloads/Development-Board-C-Examples/20.standard_robot/application/detect_task.c	2024-04-08 11:10:52
@@ -3,7 +3,7 @@
   * @file       detect_task.c/h
   * @brief      detect error task, judged by receiving data time. provide detect
                 hook function, error exist function.
   * @note       
   * @history
   *  Version    Date            Author          Modification
@@ -29,22 +29,22 @@
     3. if XXX_TOE has data_is_error_fun ,solve_lost_fun,solve_data_error_fun function, 
         please assign to function pointer.
     4. when XXX_TOE sensor data come, add the function detect_hook(XXX_TOE) function.
     enum errorList
     {
         ...
         ERROR_LIST_LENGHT,
     };
         uint16_t set_item[ERROR_LIST_LENGHT][3] =
         {
             ...
             {n,n,n}, //XX_TOE
         };
   ==============================================================================
   @endverbatim
   ****************************(C) COPYRIGHT 2019 DJI****************************
@@ -60,8 +60,8 @@
   * @retval         none
   */
 /**
   * @retval         none
   */
 static void detect_init(uint32_t time);
@@ -83,7 +83,7 @@
   * @retval         none
   */
 /**
   * @param[in]      pvParameters: NULL
   * @retval         none
   */
@@ -91,9 +91,9 @@
 {
     static uint32_t system_time;
     system_time = xTaskGetTickCount();
     detect_init(system_time);
     vTaskDelay(DETECT_TASK_INIT_TIME);
 
     while (1)
@@ -108,25 +108,25 @@
         for (int i = 0; i < ERROR_LIST_LENGHT; i++)
         {
             //disable, continue
             if (error_list[i].enable == 0)
             {
                 continue;
             }
 
             if (system_time - error_list[i].new_time > error_list[i].set_offline_time)
             {
                 if (error_list[i].error_exist == 0)
                 {
                     //record error and time
                     error_list[i].is_lost = 1;
                     error_list[i].error_exist = 1;
                     error_list[i].lost_time = system_time;
                 }
                 //judge the priority,save the highest priority ,
                 if (error_list[i].priority > error_list[error_num_display].priority)
                 {
                     error_num_display = i;
@@ -136,7 +136,7 @@
                 error_list[ERROR_LIST_LENGHT].is_lost = 1;
                 error_list[ERROR_LIST_LENGHT].error_exist = 1;
                 //if solve_lost_fun != NULL, run it
                 if (error_list[i].solve_lost_fun != NULL)
                 {
                     error_list[i].solve_lost_fun();
@@ -145,14 +145,14 @@
             else if (system_time - error_list[i].work_time < error_list[i].set_online_time)
             {
                 //just online, maybe unstable, only record
                 error_list[i].is_lost = 0;
                 error_list[i].error_exist = 1;
             }
             else
             {
                 error_list[i].is_lost = 0;
                 //judge if exist data error
                 if (error_list[i].data_is_error != NULL)
                 {
@@ -163,7 +163,7 @@
                     error_list[i].error_exist = 0;
                 }
                 //calc frequency
                 if (error_list[i].new_time > error_list[i].last_time)
                 {
                     error_list[i].frequency = configTICK_RATE_HZ / (fp32)(error_list[i].new_time - error_list[i].last_time);
@@ -185,9 +185,9 @@
   * @retval         true (eror) or false (no error)
   */
 /**
   */
 bool_t toe_is_error(uint8_t toe)
 {
@@ -200,8 +200,8 @@
   * @retval         none
   */
 /**
   * @retval         none
   */
 void detect_hook(uint8_t toe)
@@ -244,23 +244,19 @@
   * @retval         the point of error_list
   */
 /**
   * @param[in]      none
   */
 const error_t *get_error_list_point(void)
 {
     return error_list;
 }
 
-extern uint8_t RC_data_is_error(void);
-extern void slove_RC_lost(void);
-extern void slove_data_error(void);
-
 extern void OLED_com_reset(void);
 static void detect_init(uint32_t time)
 {
     uint16_t set_item[ERROR_LIST_LENGHT][3] =
         {
             {30, 40, 15},   //SBUS
@@ -303,8 +299,8 @@
     error_list[OLED_TOE].solve_lost_fun = OLED_com_reset;
     error_list[OLED_TOE].solve_data_error_fun = NULL;
 
-    error_list[DBUS_TOE].data_is_error_fun = RC_data_is_error;
-    error_list[DBUS_TOE].solve_lost_fun = slove_RC_lost;
-    error_list[DBUS_TOE].solve_data_error_fun = slove_data_error;
+//    error_list[DBUSTOE].dataIsErrorFun = RC_data_is_error;
+//    error_list[DBUSTOE].solveLostFun = slove_RC_lost;
+//    error_list[DBUSTOE].solveDataErrorFun = slove_data_error;
 
 }
diff -bur ./application/gimbal_behaviour.c /Users/jperezch/Downloads/Development-Board-C-Examples/20.standard_robot/application/gimbal_behaviour.c
--- ./application/gimbal_behaviour.c	2024-04-23 13:44:24
+++ /Users/jperezch/Downloads/Development-Board-C-Examples/20.standard_robot/application/gimbal_behaviour.c	2024-04-08 11:10:52
@@ -1,4 +1,3 @@
-
 /**
   ****************************(C) COPYRIGHT 2019 DJI****************************
   * @file       gimbal_task.c/h
@@ -8,10 +7,10 @@
   *             gyro mode: use euler angle to control, encond mode: use enconde
   *             angle to control. and has some special mode:cali mode, motionless
   *             mode.
-  *             完成云台控制任务，由于云台使用陀螺仪解算出的角度，其范围在（-pi,pi）
-  *             故而设置目标角度均为范围，存在许多对角度计算的函数。云台主要分为2种
-  *             状态，陀螺仪控制状态是利用板载陀螺仪解算的姿态角进行控制，编码器控制
-  *             状态是通过电机反馈的编码值控制的校准，此外还有校准状态，停止状态等。
   * @note       
   * @history
   *  Version    Date            Author          Modification
@@ -50,27 +49,27 @@
         }
 
         
-    如果要添加一个新的行为模式
-    1.首先，在gimbal_behaviour.h文件中， 添加一个新行为名字在 gimbal_behaviour_e
     erum
     {  
         ...
         ...
-        GIMBAL_XXX_XXX, // 新添加的
     }gimbal_behaviour_e,
 
-    2. 实现一个新的函数 gimbal_xxx_xxx_control(fp32 *yaw, fp32 *pitch, gimbal_control_t *gimbal_control_set);
-        "yaw, pitch" 参数是云台运动控制输入量
-        第一个参数: 'yaw' 通常控制yaw轴移动,通常是角度增量,正值是逆时针运动,负值是顺时针
-        第二个参数: 'pitch' 通常控制pitch轴移动,通常是角度增量,正值是逆时针运动,负值是顺时针
-        在这个新的函数, 你能给 "yaw"和"pitch"赋值想要的参数
-    3.  在"gimbal_behavour_set"这个函数中，添加新的逻辑判断，给gimbal_behaviour赋值成GIMBAL_XXX_XXX
-        在gimbal_behaviour_mode_set函数最后，添加"else if(gimbal_behaviour == GIMBAL_XXX_XXX)" ,然后选择一种云台控制模式
-        3种:
-        GIMBAL_MOTOR_RAW : 使用'yaw' and 'pitch' 作为电机电流设定值,直接发送到CAN总线上.
-        GIMBAL_MOTOR_ENCONDE : 'yaw' and 'pitch' 是角度增量,  控制编码相对角度.
-        GIMBAL_MOTOR_GYRO : 'yaw' and 'pitch' 是角度增量,  控制陀螺仪绝对角度.
-    4.  在"gimbal_behaviour_control_set" 函数的最后，添加
         else if(gimbal_behaviour == GIMBAL_XXX_XXX)
         {
             gimbal_xxx_xxx_control(&rc_add_yaw, &rc_add_pit, gimbal_control_set);
@@ -88,7 +87,7 @@
 #include "user_lib.h"
 
 //when gimbal is in calibrating, set buzzer frequency and strenght
-//当云台在校准, 设置蜂鸣器频率和强度
 #define gimbal_warn_buzzer_on() buzzer_on(31, 20000)
 #define gimbal_warn_buzzer_off() buzzer_off()
 
@@ -100,10 +99,10 @@
   * @param          deadline
   */
 /**
-  * @brief          遥控器的死区判断，因为遥控器的拨杆在中位的时候，不一定为0，
-  * @param          输入的遥控器值
-  * @param          输出的死区处理后遥控器值
-  * @param          死区值
   */
 #define rc_deadband_limit(input, output, dealine)        \
     {                                                    \
@@ -129,14 +128,14 @@
   * @param          cali step, +1 by one step
   */
 /**
-  * @brief          通过判断角速度来判断云台是否到达极限位置
-  * @param          对应轴的角速度，单位rad/s
-  * @param          计时时间，到达GIMBAL_CALI_STEP_TIME的时间后归零
-  * @param          记录的角度 rad
-  * @param          反馈的角度 rad
-  * @param          记录的编码值 raw
-  * @param          反馈的编码值 raw
-  * @param          校准的步骤 完成一次 加一
   */
 #define gimbal_cali_gyro_judge(gyro, cmd_time, angle_set, angle, ecd_set, ecd, step) \
     {                                                                                \
@@ -159,8 +158,8 @@
   * @retval         none
   */
 /**
-  * @brief          云台行为状态机设置.
-  * @param[in]      gimbal_mode_set: 云台数据指针
   * @retval         none
   */
 static void gimbal_behavour_set(gimbal_control_t *gimbal_mode_set);
@@ -175,11 +174,11 @@
   * @retval         none
   */
 /**
-  * @brief          当云台行为模式是GIMBAL_ZERO_FORCE, 这个函数会被调用,云台控制模式是raw模式.原始模式意味着
-  *                 设定值会直接发送到CAN总线上,这个函数将会设置所有为0.
-  * @param[in]      yaw:发送yaw电机的原始值，会直接通过can 发送到电机
-  * @param[in]      pitch:发送pitch电机的原始值，会直接通过can 发送到电机
-  * @param[in]      gimbal_control_set: 云台数据指针
   * @retval         none
   */
 static void gimbal_zero_force_control(fp32 *yaw, fp32 *pitch, gimbal_control_t *gimbal_control_set);
@@ -194,11 +193,11 @@
   * @retval         none
   */
 /**
-  * @brief          云台初始化控制，电机是陀螺仪角度控制，云台先抬起pitch轴，后旋转yaw轴
-  * @param[out]     yaw轴角度控制，为角度的增量 单位 rad
-  * @param[out]     pitch轴角度控制，为角度的增量 单位 rad
-  * @param[in]      云台数据指针
-  * @retval         返回空
   */
 static void gimbal_init_control(fp32 *yaw, fp32 *pitch, gimbal_control_t *gimbal_control_set);
 
@@ -213,11 +212,11 @@
   * @retval         none
   */
 /**
-  * @brief          云台校准控制，电机是raw控制，云台先抬起pitch，放下pitch，在正转yaw，最后反转yaw，记录当时的角度和编码值
   * @author         RM
-  * @param[out]     yaw:发送yaw电机的原始值，会直接通过can 发送到电机
-  * @param[out]     pitch:发送pitch电机的原始值，会直接通过can 发送到电机
-  * @param[in]      gimbal_control_set:云台数据指针
   * @retval         none
   */
 static void gimbal_cali_control(fp32 *yaw, fp32 *pitch, gimbal_control_t *gimbal_control_set);
@@ -231,10 +230,10 @@
   * @retval         none
   */
 /**
-  * @brief          云台陀螺仪控制，电机是陀螺仪角度控制，
-  * @param[out]     yaw: yaw轴角度控制，为角度的增量 单位 rad
-  * @param[out]     pitch:pitch轴角度控制，为角度的增量 单位 rad
-  * @param[in]      gimbal_control_set:云台数据指针
   * @retval         none
   */
 static void gimbal_absolute_angle_control(fp32 *yaw, fp32 *pitch, gimbal_control_t *gimbal_control_set);
@@ -248,10 +247,10 @@
   * @retval         none
   */
 /**
-  * @brief          云台编码值控制，电机是相对角度控制，
-  * @param[in]      yaw: yaw轴角度控制，为角度的增量 单位 rad
-  * @param[in]      pitch: pitch轴角度控制，为角度的增量 单位 rad
-  * @param[in]      gimbal_control_set: 云台数据指针
   * @retval         none
   */
 static void gimbal_relative_angle_control(fp32 *yaw, fp32 *pitch, gimbal_control_t *gimbal_control_set);
@@ -265,16 +264,16 @@
   * @retval         none
   */
 /**
-  * @brief          云台进入遥控器无输入控制，电机是相对角度控制，
   * @author         RM
-  * @param[in]      yaw: yaw轴角度控制，为角度的增量 单位 rad
-  * @param[in]      pitch: pitch轴角度控制，为角度的增量 单位 rad
-  * @param[in]      gimbal_control_set:云台数据指针
   * @retval         none
   */
 static void gimbal_motionless_control(fp32 *yaw, fp32 *pitch, gimbal_control_t *gimbal_control_set);
 
-//云台行为状态机
 static gimbal_behaviour_e gimbal_behaviour = GIMBAL_ZERO_FORCE;
 
 /**
@@ -284,8 +283,8 @@
   * @retval         none
   */
 /**
-  * @brief          被gimbal_set_mode函数调用在gimbal_task.c,云台行为状态机以及电机状态机设置
-  * @param[out]     gimbal_mode_set: 云台数据指针
   * @retval         none
   */
 
@@ -296,11 +295,11 @@
         return;
     }
     //set gimbal_behaviour variable
-    //云台行为状态机设置
     gimbal_behavour_set(gimbal_mode_set);
 
     //accoring to gimbal_behaviour, set motor control mode
-    //根据云台行为状态机设置电机状态机
     if (gimbal_behaviour == GIMBAL_ZERO_FORCE)
     {
         gimbal_mode_set->gimbal_yaw_motor.gimbal_motor_mode = GIMBAL_MOTOR_RAW;
@@ -342,10 +341,10 @@
   * @retval         none
   */
 /**
-  * @brief          云台行为控制，根据不同行为采用不同控制函数
-  * @param[out]     add_yaw:设置的yaw角度增加值，单位 rad
-  * @param[out]     add_pitch:设置的pitch角度增加值，单位 rad
-  * @param[in]      gimbal_mode_set:云台数据指针
   * @retval         none
   */
 void gimbal_behaviour_control_set(fp32 *add_yaw, fp32 *add_pitch, gimbal_control_t *gimbal_control_set)
@@ -390,7 +389,7 @@
   * @retval         1: no move 0:normal
   */
 /**
-  * @brief          云台在某些行为下，需要底盘不动
   * @param[in]      none
   * @retval         1: no move 0:normal
   */
@@ -413,7 +412,7 @@
   * @retval         1: no move 0:normal
   */
 /**
-  * @brief          云台在某些行为下，需要射击停止
   * @param[in]      none
   * @retval         1: no move 0:normal
   */
@@ -437,8 +436,8 @@
   * @retval         none
   */
 /**
-  * @brief          云台行为状态机设置.
-  * @param[in]      gimbal_mode_set: 云台数据指针
   * @retval         none
   */
 static void gimbal_behavour_set(gimbal_control_t *gimbal_mode_set)
@@ -448,13 +447,13 @@
         return;
     }
     //in cali mode, return
-    //校准行为，return 不会设置其他的模式
     if (gimbal_behaviour == GIMBAL_CALI && gimbal_mode_set->gimbal_cali.step != GIMBAL_CALI_END_STEP)
     {
         return;
     }
     //if other operate make step change to start, means enter cali mode
-    //如果外部使得校准步骤从0 变成 start，则进入校准模式
     if (gimbal_mode_set->gimbal_cali.step == GIMBAL_CALI_START_STEP && !toe_is_error(DBUS_TOE))
     {
         gimbal_behaviour = GIMBAL_CALI;
@@ -462,7 +461,7 @@
     }
 
     //init mode, judge if gimbal is in middle place
-    //初始化模式判断是否到达中值位置
     if (gimbal_behaviour == GIMBAL_INIT)
     {
         static uint16_t init_time = 0;
@@ -487,7 +486,7 @@
             }
         }
 
-        //超过初始化最大时间，或者已经稳定到中值一段时间，退出初始化状态开关打下档，或者掉线
         if (init_time < GIMBAL_INIT_TIME && init_stop_time < GIMBAL_INIT_STOP_TIME &&
             !switch_is_down(gimbal_mode_set->gimbal_rc_ctrl->rc.s[GIMBAL_MODE_CHANNEL]) && !toe_is_error(DBUS_TOE))
         {
@@ -500,7 +499,7 @@
         }
     }
 
-    //开关控制 云台状态
     if (switch_is_down(gimbal_mode_set->gimbal_rc_ctrl->rc.s[GIMBAL_MODE_CHANNEL]))
     {
         gimbal_behaviour = GIMBAL_ZERO_FORCE;
@@ -520,7 +519,7 @@
     }
 
     //enter init mode
-    //判断进入init状态机
     {
         static gimbal_behaviour_e last_gimbal_behaviour = GIMBAL_ZERO_FORCE;
         if (last_gimbal_behaviour == GIMBAL_ZERO_FORCE && gimbal_behaviour != GIMBAL_ZERO_FORCE)
@@ -544,11 +543,11 @@
   * @retval         none
   */
 /**
-  * @brief          当云台行为模式是GIMBAL_ZERO_FORCE, 这个函数会被调用,云台控制模式是raw模式.原始模式意味着
-  *                 设定值会直接发送到CAN总线上,这个函数将会设置所有为0.
-  * @param[in]      yaw:发送yaw电机的原始值，会直接通过can 发送到电机
-  * @param[in]      pitch:发送pitch电机的原始值，会直接通过can 发送到电机
-  * @param[in]      gimbal_control_set: 云台数据指针
   * @retval         none
   */
 static void gimbal_zero_force_control(fp32 *yaw, fp32 *pitch, gimbal_control_t *gimbal_control_set)
@@ -571,12 +570,12 @@
   * @retval         none
   */
 /**
-  * @brief          云台初始化控制，电机是陀螺仪角度控制，云台先抬起pitch轴，后旋转yaw轴
   * @author         RM
-  * @param[out]     yaw轴角度控制，为角度的增量 单位 rad
-  * @param[out]     pitch轴角度控制，为角度的增量 单位 rad
-  * @param[in]      云台数据指针
-  * @retval         返回空
   */
 static void gimbal_init_control(fp32 *yaw, fp32 *pitch, gimbal_control_t *gimbal_control_set)
 {
@@ -585,7 +584,7 @@
         return;
     }
 
-    //初始化状态控制量计算
     if (fabs(INIT_PITCH_SET - gimbal_control_set->gimbal_pitch_motor.absolute_angle) > GIMBAL_INIT_ANGLE_ERROR)
     {
         *pitch = (INIT_PITCH_SET - gimbal_control_set->gimbal_pitch_motor.absolute_angle) * GIMBAL_INIT_PITCH_SPEED;
@@ -609,11 +608,11 @@
   * @retval         none
   */
 /**
-  * @brief          云台校准控制，电机是raw控制，云台先抬起pitch，放下pitch，在正转yaw，最后反转yaw，记录当时的角度和编码值
   * @author         RM
-  * @param[out]     yaw:发送yaw电机的原始值，会直接通过can 发送到电机
-  * @param[out]     pitch:发送pitch电机的原始值，会直接通过can 发送到电机
-  * @param[in]      gimbal_control_set:云台数据指针
   * @retval         none
   */
 static void gimbal_cali_control(fp32 *yaw, fp32 *pitch, gimbal_control_t *gimbal_control_set)
@@ -630,7 +629,7 @@
         *pitch = GIMBAL_CALI_MOTOR_SET;
         *yaw = 0;
 
-        //判断陀螺仪数据， 并记录最大最小角度数据
         gimbal_cali_gyro_judge(gimbal_control_set->gimbal_pitch_motor.motor_gyro, cali_time, gimbal_control_set->gimbal_cali.max_pitch,
                                gimbal_control_set->gimbal_pitch_motor.absolute_angle, gimbal_control_set->gimbal_cali.max_pitch_ecd,
                                gimbal_control_set->gimbal_pitch_motor.gimbal_motor_measure->ecd, gimbal_control_set->gimbal_cali.step);
@@ -679,10 +678,10 @@
   * @retval         none
   */
 /**
-  * @brief          云台陀螺仪控制，电机是陀螺仪角度控制，
-  * @param[out]     yaw: yaw轴角度控制，为角度的增量 单位 rad
-  * @param[out]     pitch:pitch轴角度控制，为角度的增量 单位 rad
-  * @param[in]      gimbal_control_set:云台数据指针
   * @retval         none
   */
 static void gimbal_absolute_angle_control(fp32 *yaw, fp32 *pitch, gimbal_control_t *gimbal_control_set)
@@ -711,7 +710,7 @@
             if (gimbal_turn_flag == 0)
             {
                 gimbal_turn_flag = 1;
-                //保存掉头的目标值
                 gimbal_end_angle = rad_format(gimbal_control_set->gimbal_yaw_motor.absolute_angle + PI);
             }
         }
@@ -719,7 +718,7 @@
 
         if (gimbal_turn_flag)
         {
-            //不断控制到掉头的目标值，正转，反装是随机
             if (rad_format(gimbal_end_angle - gimbal_control_set->gimbal_yaw_motor.absolute_angle) > 0.0f)
             {
                 *yaw += TURN_SPEED;
@@ -729,7 +728,7 @@
                 *yaw -= TURN_SPEED;
             }
         }
-        //到达pi （180°）后停止
         if (gimbal_turn_flag && fabs(rad_format(gimbal_end_angle - gimbal_control_set->gimbal_yaw_motor.absolute_angle)) < 0.01f)
         {
             gimbal_turn_flag = 0;
@@ -747,10 +746,10 @@
   * @retval         none
   */
 /**
-  * @brief          云台编码值控制，电机是相对角度控制，
-  * @param[in]      yaw: yaw轴角度控制，为角度的增量 单位 rad
-  * @param[in]      pitch: pitch轴角度控制，为角度的增量 单位 rad
-  * @param[in]      gimbal_control_set: 云台数据指针
   * @retval         none
   */
 static void gimbal_relative_angle_control(fp32 *yaw, fp32 *pitch, gimbal_control_t *gimbal_control_set)
@@ -779,11 +778,11 @@
   * @retval         none
   */
 /**
-  * @brief          云台进入遥控器无输入控制，电机是相对角度控制，
   * @author         RM
-  * @param[in]      yaw: yaw轴角度控制，为角度的增量 单位 rad
-  * @param[in]      pitch: pitch轴角度控制，为角度的增量 单位 rad
-  * @param[in]      gimbal_control_set:云台数据指针
   * @retval         none
   */
 static void gimbal_motionless_control(fp32 *yaw, fp32 *pitch, gimbal_control_t *gimbal_control_set)
diff -bur ./application/gimbal_task.h /Users/jperezch/Downloads/Development-Board-C-Examples/20.standard_robot/application/gimbal_task.h
--- ./application/gimbal_task.h	2024-04-23 13:44:24
+++ /Users/jperezch/Downloads/Development-Board-C-Examples/20.standard_robot/application/gimbal_task.h	2024-04-08 11:10:52
@@ -7,10 +7,10 @@
   *             gyro mode: use euler angle to control, encond mode: use enconde
   *             angle to control. and has some special mode:cali mode, motionless
   *             mode.
   * @note       
   * @history
   *  Version    Date            Author          Modification
@@ -32,7 +32,7 @@
 #include "pid.h"
 #include "remote_control.h"
 //pitch speed close-loop PID params, max out and max iout
 #define PITCH_SPEED_PID_KP        2900.0f
 #define PITCH_SPEED_PID_KI        60.0f
 #define PITCH_SPEED_PID_KD        0.0f
@@ -40,7 +40,7 @@
 #define PITCH_SPEED_PID_MAX_IOUT  10000.0f
 
 //yaw speed close-loop PID params, max out and max iout
 #define YAW_SPEED_PID_KP        3600.0f
 #define YAW_SPEED_PID_KI        20.0f
 #define YAW_SPEED_PID_KD        0.0f
@@ -48,7 +48,7 @@
 #define YAW_SPEED_PID_MAX_IOUT  5000.0f
 
 //pitch gyro angle close-loop PID params, max out and max iout
 #define PITCH_GYRO_ABSOLUTE_PID_KP 15.0f
 #define PITCH_GYRO_ABSOLUTE_PID_KI 0.0f
 #define PITCH_GYRO_ABSOLUTE_PID_KD 0.0f
@@ -57,7 +57,7 @@
 #define PITCH_GYRO_ABSOLUTE_PID_MAX_IOUT 0.0f
 
 //yaw gyro angle close-loop PID params, max out and max iout
 #define YAW_GYRO_ABSOLUTE_PID_KP        26.0f
 #define YAW_GYRO_ABSOLUTE_PID_KI        0.0f
 #define YAW_GYRO_ABSOLUTE_PID_KD        0.3f
@@ -65,7 +65,7 @@
 #define YAW_GYRO_ABSOLUTE_PID_MAX_IOUT  0.0f
 
 //pitch encode angle close-loop PID params, max out and max iout
 #define PITCH_ENCODE_RELATIVE_PID_KP 15.0f
 #define PITCH_ENCODE_RELATIVE_PID_KI 0.00f
 #define PITCH_ENCODE_RELATIVE_PID_KD 0.0f
@@ -74,7 +74,7 @@
 #define PITCH_ENCODE_RELATIVE_PID_MAX_IOUT 0.0f
 
 //yaw encode angle close-loop PID params, max out and max iout
 #define YAW_ENCODE_RELATIVE_PID_KP        8.0f
 #define YAW_ENCODE_RELATIVE_PID_KI        0.0f
 #define YAW_ENCODE_RELATIVE_PID_KD        0.0f
@@ -82,23 +82,23 @@
 #define YAW_ENCODE_RELATIVE_PID_MAX_IOUT  0.0f
 
 
 #define GIMBAL_TASK_INIT_TIME 201
-#define YAW_CHANNEL   0
-#define PITCH_CHANNEL 2
-#define GIMBAL_MODE_CHANNEL 5//rc.sc[0]
+#define YAW_CHANNEL   2
+#define PITCH_CHANNEL 3
+#define GIMBAL_MODE_CHANNEL 0
 
 #define TURN_KEYBOARD KEY_PRESSED_OFFSET_F
 //turn speed
 #define TURN_SPEED    0.04f
 #define TEST_KEYBOARD KEY_PRESSED_OFFSET_R
 //rocker value deadband
 #define RC_DEADBAND   10
 
 
@@ -114,28 +114,28 @@
 #define GIMBAL_CONTROL_TIME 1
 
 //test mode, 0 close, 1 open
 #define GIMBAL_TEST_MODE 0
 
 #define PITCH_TURN  1
 #define YAW_TURN    0
 
 #define HALF_ECD_RANGE  4096
 #define ECD_RANGE       8191
 #define GIMBAL_INIT_ANGLE_ERROR     0.1f
 #define GIMBAL_INIT_STOP_TIME       100
 #define GIMBAL_INIT_TIME            6000
 #define GIMBAL_CALI_REDUNDANT_ANGLE 0.1f
 #define GIMBAL_INIT_PITCH_SPEED     0.004f
 #define GIMBAL_INIT_YAW_SPEED       0.005f
 
 #define INIT_YAW_SET    0.0f
 #define INIT_PITCH_SET  0.0f
 
 #define GIMBAL_CALI_MOTOR_SET   8000
 #define GIMBAL_CALI_STEP_TIME   2000
 #define GIMBAL_CALI_GYRO_LIMIT  0.1f
@@ -148,20 +148,20 @@
 #define GIMBAL_CALI_START_STEP  GIMBAL_CALI_PITCH_MAX_STEP
 #define GIMBAL_CALI_END_STEP    5
 
 #define GIMBAL_MOTIONLESS_RC_DEADLINE 10
 #define GIMBAL_MOTIONLESS_TIME_MAX    3000
 
 #ifndef MOTOR_ECD_TO_RAD
 #define MOTOR_ECD_TO_RAD 0.000766990394f //      2*  PI  /8192
 #endif
 
 typedef enum
 {
 } gimbal_motor_mode_e;
 
 typedef struct
@@ -238,9 +238,9 @@
   * @retval         yaw motor data point
   */
 /**
   * @param[in]      none
   */
 extern const gimbal_motor_t *get_yaw_motor_point(void);
 
@@ -250,7 +250,7 @@
   * @retval         pitch motor data point
   */
 /**
   * @param[in]      none
   * @retval         pitch
   */
@@ -262,8 +262,8 @@
   * @retval         none
   */
 /**
   * @retval         none
   */
 
@@ -280,15 +280,15 @@
   * @retval         none
   */
 /**
   */
 extern bool_t cmd_cali_gimbal_hook(uint16_t *yaw_offset, uint16_t *pitch_offset, fp32 *max_yaw, fp32 *min_yaw, fp32 *max_pitch, fp32 *min_pitch);
 
@@ -303,15 +303,15 @@
   * @retval         none
   */
 /**
   */
 extern void set_cali_gimbal_hook(const uint16_t yaw_offset, const uint16_t pitch_offset, const fp32 max_yaw, const fp32 min_yaw, const fp32 max_pitch, const fp32 min_pitch);
 #endif
diff -bur ./application/remote_control.c /Users/jperezch/Downloads/Development-Board-C-Examples/20.standard_robot/application/remote_control.c
--- ./application/remote_control.c	2024-04-23 13:44:24
+++ /Users/jperezch/Downloads/Development-Board-C-Examples/20.standard_robot/application/remote_control.c	2024-04-08 11:10:52
@@ -1,10 +1,10 @@
 /**
   ****************************(C) COPYRIGHT 2019 DJI****************************
   * @file       remote_control.c/h
   * @history
   *  Version    Date            Author          Modification
   *  V1.0.0     Dec-26-2018     RM              1. done
@@ -26,17 +26,17 @@
 #include "string.h"
 
 #include "detect_task.h"
-#include "referee_usart_task.h"
 
 
-#define RC_CHANNAL_ERROR_VALUE 65536//2048(funcino masomenos) //700 (original)
 
+#define RC_CHANNAL_ERROR_VALUE 700
+
 extern UART_HandleTypeDef huart3;
 extern DMA_HandleTypeDef hdma_usart3_rx;
 
 
 static int16_t RC_abs(int16_t value);
 /**
   * @brief          remote control protocol resolution
@@ -45,17 +45,17 @@
   * @retval         none
   */
 /**
   * @retval         none
   */
 static void sbus_to_rc(volatile const uint8_t *sbus_buf, RC_ctrl_t *rc_ctrl);
 
 //remote control data 
 RC_ctrl_t rc_ctrl;
 static uint8_t sbus_rx_buf[2][SBUS_RX_BUF_NUM];
 
 
@@ -65,7 +65,7 @@
   * @retval         none
   */
 /**
   * @param[in]      none
   * @retval         none
   */
@@ -79,19 +79,19 @@
   * @retval         remote control data point
   */
 /**
   * @param[in]      none
   */
 const RC_ctrl_t *get_remote_control_point(void)
 {
     return &rc_ctrl;
 }
 
 uint8_t RC_data_is_error(void)
 {
     if (RC_abs(rc_ctrl.rc.ch[0]) > RC_CHANNAL_ERROR_VALUE)
     {
         goto error;
@@ -108,6 +108,14 @@
     {
         goto error;
     }
+    if (rc_ctrl.rc.s[0] == 0)
+    {
+        goto error;
+    }
+    if (rc_ctrl.rc.s[1] == 0)
+    {
+        goto error;
+    }
     return 0;
 
 error:
@@ -136,10 +144,10 @@
     RC_restart(SBUS_RX_BUF_NUM);
 }
 
 void USART3_IRQHandler(void)
 {
     {
         __HAL_UART_CLEAR_PEFLAG(&huart3);
     }
@@ -158,29 +166,29 @@
             __HAL_DMA_DISABLE(&hdma_usart3_rx);
 
             //get receive data length, length = set_data_length - remain_length
             this_time_rx_len = SBUS_RX_BUF_NUM - hdma_usart3_rx.Instance->NDTR;
 
             //reset set_data_lenght
             hdma_usart3_rx.Instance->NDTR = SBUS_RX_BUF_NUM;
 
             //set memory buffer 1
             hdma_usart3_rx.Instance->CR |= DMA_SxCR_CT;
             
             //enable DMA
             __HAL_DMA_ENABLE(&hdma_usart3_rx);
 
-            //if(this_time_rx_len == RC_FRAME_LENGTH)
-            //{
+            if(this_time_rx_len == RC_FRAME_LENGTH)
+            {
                 sbus_to_rc(sbus_rx_buf[0], &rc_ctrl);
                 detect_hook(DBUS_TOE);
                 sbus_to_usart1(sbus_rx_buf[0]);
-            //}
             }
+        }
         else
         {
             /* Current memory buffer used is Memory 1 */
@@ -189,35 +197,35 @@
             __HAL_DMA_DISABLE(&hdma_usart3_rx);
 
             //get receive data length, length = set_data_length - remain_length
             this_time_rx_len = SBUS_RX_BUF_NUM - hdma_usart3_rx.Instance->NDTR;
 
             //reset set_data_lenght
             hdma_usart3_rx.Instance->NDTR = SBUS_RX_BUF_NUM;
 
             //set memory buffer 0
             DMA1_Stream1->CR &= ~(DMA_SxCR_CT);
             
             //enable DMA
             __HAL_DMA_ENABLE(&hdma_usart3_rx);
 
-            //if(this_time_rx_len == RC_FRAME_LENGTH)
-            //{
+            if(this_time_rx_len == RC_FRAME_LENGTH)
+            {
                 sbus_to_rc(sbus_rx_buf[1], &rc_ctrl);
                 detect_hook(DBUS_TOE);
                 sbus_to_usart1(sbus_rx_buf[1]);
-           // }
             }
         }
+    }
 
 }
 
 static int16_t RC_abs(int16_t value)
 {
     if (value > 0)
@@ -236,18 +244,11 @@
   * @retval         none
   */
 /**
   * @retval         none
   */
-
-  
-  //uint8_t sbus_buf_reverse[2][SBUS_RX_BUF_NUM];
-
-  // Comment if using other controller remote_control.h
-
-
 static void sbus_to_rc(volatile const uint8_t *sbus_buf, RC_ctrl_t *rc_ctrl)
 {
     if (sbus_buf == NULL || rc_ctrl == NULL)
@@ -255,22 +256,6 @@
         return;
     }
 
-
-    #ifdef USING_FLYSKY
-
-        //rc_ctrl->rc.ch[0] = (sbus_buf[0] | (sbus_buf[1] << 8)) & 0x0ff;        	//!< Channel 0
-        rc_ctrl->rc.ch[0] = ((sbus_buf[1] >> 3) | (sbus_buf[2] << 5)) & 0x0ff;		//!< Channel 0
-        rc_ctrl->rc.ch[1] = ((sbus_buf[2] >> 6) | (sbus_buf[3] << 2) |          	//!< Channel 1
-                            (sbus_buf[4] << 10)) &0x0ff;
-        rc_ctrl->rc.ch[2] = ((sbus_buf[4] >> 1) | (sbus_buf[5] << 7)) & 0x0ff; 		//!< Channel 2
-        rc_ctrl->rc.ch[3] = ((sbus_buf[5] >> 4) |(sbus_buf[6] << 4)) & 0x0ff;     //!< Channel 3
-        rc_ctrl->rc.s[0] = ((sbus_buf[6] >> 1) & 0x0A) >> 2 ;                 	//!< Switch right
-				rc_ctrl->rc.s[1] = ((sbus_buf[8] >> 6) & 0x0A) ;                 	//!< Switch right
-        // TODO: Find if we should use the offset
-        rc_ctrl->rc.ch[4] = sbus_buf[11] | (sbus_buf[12] << 8);                 //NULL
-
-
-    #else
     rc_ctrl->rc.ch[0] = (sbus_buf[0] | (sbus_buf[1] << 8)) & 0x07ff;        //!< Channel 0
     rc_ctrl->rc.ch[1] = ((sbus_buf[1] >> 3) | (sbus_buf[2] << 5)) & 0x07ff; //!< Channel 1
     rc_ctrl->rc.ch[2] = ((sbus_buf[2] >> 6) | (sbus_buf[3] << 2) |          //!< Channel 2
@@ -286,9 +271,6 @@
         rc_ctrl->key.v = sbus_buf[14] | (sbus_buf[15] << 8);                    //!< KeyBoard value
         rc_ctrl->rc.ch[4] = sbus_buf[16] | (sbus_buf[17] << 8);                 //NULL
 
-    #endif
-
-    
     rc_ctrl->rc.ch[0] -= RC_CH_VALUE_OFFSET;
     rc_ctrl->rc.ch[1] -= RC_CH_VALUE_OFFSET;
     rc_ctrl->rc.ch[2] -= RC_CH_VALUE_OFFSET;
@@ -302,8 +284,8 @@
   * @retval         none
   */
 /**
   * @retval         none
   */
 void sbus_to_usart1(uint8_t *sbus)
diff -bur ./application/remote_control.h /Users/jperezch/Downloads/Development-Board-C-Examples/20.standard_robot/application/remote_control.h
--- ./application/remote_control.h	2024-04-23 13:44:24
+++ /Users/jperezch/Downloads/Development-Board-C-Examples/20.standard_robot/application/remote_control.h	2024-04-08 11:10:52
@@ -1,9 +1,9 @@
 /**
   ****************************(C) COPYRIGHT 2016 DJI****************************
   * @file       remote_control.c/h
   * @note       
   * @history
   *  Version    Date            Author          Modification
@@ -24,7 +24,7 @@
 
 #define SBUS_RX_BUF_NUM 36u
 
-#define RC_FRAME_LENGTH 10u//18u (original)
+#define RC_FRAME_LENGTH 18u
 
 #define RC_CH_VALUE_MIN         ((uint16_t)364)
 #define RC_CH_VALUE_OFFSET      ((uint16_t)1024)
@@ -34,17 +34,9 @@
 #define RC_SW_UP                ((uint16_t)1)
 #define RC_SW_MID               ((uint16_t)3)
 #define RC_SW_DOWN              ((uint16_t)2)
-#define USING_FLYSKY
-//using FLYSKY
-// #ifdef USING_FLYSKY
-         #define switch_is_down(s)       (s <= 128)
-         #define switch_is_mid(s)        (s >= -10 && s <= 10)
-         #define switch_is_up(s)         (s >= 128)
-// #else
-//        #define switch_is_down(s)       (s == RC_SW_DOWN)
-//        #define switch_is_mid(s)        (s == RC_SW_MID)
-//        #define switch_is_up(s)         (s == RC_SW_UP)
-// #endif
+#define switch_is_down(s)       (s == RC_SW_DOWN)
+#define switch_is_mid(s)        (s == RC_SW_MID)
+#define switch_is_up(s)         (s == RC_SW_UP)
 /* ----------------------- PC Key Definition-------------------------------- */
 #define KEY_PRESSED_OFFSET_W            ((uint16_t)1 << 0)
 #define KEY_PRESSED_OFFSET_S            ((uint16_t)1 << 1)
diff -bur ./application/usb_task.c /Users/jperezch/Downloads/Development-Board-C-Examples/20.standard_robot/application/usb_task.c
--- ./application/usb_task.c	2024-04-23 13:44:24
+++ /Users/jperezch/Downloads/Development-Board-C-Examples/20.standard_robot/application/usb_task.c	2024-04-08 11:10:52
@@ -1,7 +1,7 @@
 /**
   ****************************(C) COPYRIGHT 2019 DJI****************************
   * @file       usb_task.c/h
   * @note       
   * @history
   *  Version    Date            Author          Modification
@@ -23,7 +23,6 @@
 #include <stdio.h>
 #include <stdarg.h>
 #include "string.h"
-#include "remote_control.h"
 
 #include "detect_task.h"
 #include "voltage_task.h"
@@ -35,78 +34,46 @@
 static const char status[2][7] = {"OK", "ERROR!"};
 const error_t *error_list_usb_local;
 
-void intToBinaryString(int num, char *binaryString) {
-    int index = 0;
-    for (int i = sizeof(num) * 8 - 1; i >= 0; i--) {
 
-        binaryString[index++] = ((num >> i) & 1) + '0';
-    }
-    binaryString[index] = '\0'; // Agrega el carácter nulo al final de la cadena
-    // usb_printf("num: %d bin: %s", num, binaryString);
 
-}
-
 void usb_task(void const * argument)
 {
     MX_USB_DEVICE_Init();
     error_list_usb_local = get_error_list_point();
    
     
-/*
-
-*/
     while(1)
     {
-
-        osDelay(500);
+        osDelay(1000);
         usb_printf(
-//            "******************************\r\n\
-//            voltage percentage:%d%% \r\n\
-//            DBUS:%s\r\n\
-//            chassis motor1:%s\r\n\
-//            chassis motor2:%s\r\n\
-//            chassis motor3:%s\r\n\
-//            chassis motor4:%s\r\n\
-//            yaw motor:%s\r\n\
-//            pitch motor:%s\r\n\
-//            trigger motor:%s\r\n\
-//            gyro sensor:%s\r\n\
-//            accel sensor:%s\r\n\
-//            mag sensor:%s\r\n\
-//            referee usart:%s\r\n",
-//            get_battery_percentage(), 
-//            status[error_list_usb_local[DBUS_TOE].error_exist],
-//            status[error_list_usb_local[CHASSIS_MOTOR1_TOE].error_exist],
-//            status[error_list_usb_local[CHASSIS_MOTOR2_TOE].error_exist],
-//            status[error_list_usb_local[CHASSIS_MOTOR3_TOE].error_exist],
-//            status[error_list_usb_local[CHASSIS_MOTOR4_TOE].error_exist],
-//            status[error_list_usb_local[YAW_GIMBAL_MOTOR_TOE].error_exist],
-//            status[error_list_usb_local[PITCH_GIMBAL_MOTOR_TOE].error_exist],
-//            status[error_list_usb_local[TRIGGER_MOTOR_TOE].error_exist],
-//            status[error_list_usb_local[BOARD_GYRO_TOE].error_exist],
-//            status[error_list_usb_local[BOARD_ACCEL_TOE].error_exist],
-//            status[error_list_usb_local[BOARD_MAG_TOE].error_exist],
-//            status[error_list_usb_local[REFEREE_TOE].error_exist]);
-            "******************************\r\n\
-            voltage percentage:%d%% \r\n\
-            DBUS:%s\r\n\
-            channel 0:%x \r\n\
-            channel 1:%x \r\n\
-            channel 2:%x \r\n\
-            channel 3:%x \r\n\
-						channel 4:%x \r\n\
-            switch 1:%d\r\n\
-            switch 2:%d\r\n\
-            ******************************\r\n",
+"******************************\r\n\
+voltage percentage:%d%% \r\n\
+DBUS:%s\r\n\
+chassis motor1:%s\r\n\
+chassis motor2:%s\r\n\
+chassis motor3:%s\r\n\
+chassis motor4:%s\r\n\
+yaw motor:%s\r\n\
+pitch motor:%s\r\n\
+trigger motor:%s\r\n\
+gyro sensor:%s\r\n\
+accel sensor:%s\r\n\
+mag sensor:%s\r\n\
+referee usart:%s\r\n\
+******************************\r\n",
                         get_battery_percentage(), 
                         status[error_list_usb_local[DBUS_TOE].error_exist],
-                        get_remote_control_point()->rc.ch[0],  
-                        get_remote_control_point()->rc.ch[1],  
-                        get_remote_control_point()->rc.ch[2],  
-                        get_remote_control_point()->rc.ch[3],
-												get_remote_control_point()->rc.ch[4],
-                        get_remote_control_point()->rc.s[0],
-                        get_remote_control_point()->rc.s[1]);
+            status[error_list_usb_local[CHASSIS_MOTOR1_TOE].error_exist],
+            status[error_list_usb_local[CHASSIS_MOTOR2_TOE].error_exist],
+            status[error_list_usb_local[CHASSIS_MOTOR3_TOE].error_exist],
+            status[error_list_usb_local[CHASSIS_MOTOR4_TOE].error_exist],
+            status[error_list_usb_local[YAW_GIMBAL_MOTOR_TOE].error_exist],
+            status[error_list_usb_local[PITCH_GIMBAL_MOTOR_TOE].error_exist],
+            status[error_list_usb_local[TRIGGER_MOTOR_TOE].error_exist],
+            status[error_list_usb_local[BOARD_GYRO_TOE].error_exist],
+            status[error_list_usb_local[BOARD_ACCEL_TOE].error_exist],
+            status[error_list_usb_local[BOARD_MAG_TOE].error_exist],
+            status[error_list_usb_local[REFEREE_TOE].error_exist]);
 
     }
 
Only in .: differences
